"""API endpoints for deep interview system."""
from typing import List, Optional, Union
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session

from app.db import get_db
from app.models.user import User
from app.models.interview_session import InterviewStatus
from app.schemas.interview import (
    InterviewStartRequest,
    InterviewSubmitAnswersRequest,
    InterviewQuestionsResponse,
    InterviewCompletedResponse,
    InterviewSessionResponse,
    InterviewSessionListResponse,
    InterviewScheduleSchema,
    InterviewQuestionSchema,
    get_stage_name,
)
from app.services.interview_service import InterviewService
from app.api.deps import get_current_user
from app.ai.interview_graph import (
    start_interview as start_interview_graph,
    submit_answers as submit_answers_graph,
)


router = APIRouter()


@router.post(
    "/start",
    response_model=InterviewQuestionsResponse,
    summary="Start a new interview session",
)
async def start_interview(
    request: InterviewStartRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Start a new multi-stage deep interview session.

    This begins Stage 1: Goal Clarification.
    Questions are dynamically generated by AI based on the topic and mode.
    """
    service = InterviewService(db)

    # Create DB session
    session = service.create_session(
        user_id=current_user.id,
        topic=request.topic,
        mode=request.mode,
        duration_months=request.duration_months,
    )

    try:
        # Start interview graph
        result = start_interview_graph(
            topic=request.topic,
            mode=request.mode,
            duration_months=request.duration_months,
            user_id=str(current_user.id),
            session_id=str(session.id),
        )

        # Update DB with state
        service.update_session_state(session, result["state"])

        # Convert questions to schema
        questions = [
            InterviewQuestionSchema(**q)
            for q in result["questions"]
        ]

        return InterviewQuestionsResponse(
            session_id=session.id,
            current_stage=result.get("current_round", 1),
            stage_name=f"라운드 {result.get('current_round', 1)}",
            questions=questions,
            is_complete=False,
            is_followup=False,
        )

    except Exception as e:
        # Clean up on error
        service.delete_session(session.id, current_user.id)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"인터뷰 시작 중 오류가 발생했습니다: {str(e)}",
        )


@router.post(
    "/{session_id}/submit",
    response_model=Union[InterviewQuestionsResponse, InterviewCompletedResponse],
    summary="Submit answers for current questions",
)
async def submit_answers(
    session_id: UUID,
    request: InterviewSubmitAnswersRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Submit answers to the current interview questions.

    Returns either:
    - More questions (follow-up or next stage)
    - Completion status with compiled context
    """
    service = InterviewService(db)

    # Get session
    session = service.get_session(session_id, current_user.id)
    if not session:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="인터뷰 세션을 찾을 수 없습니다.",
        )

    if session.status != InterviewStatus.IN_PROGRESS:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="이미 완료되거나 취소된 인터뷰입니다.",
        )

    try:
        # Convert session to state
        state = service.session_to_state(session)

        # Convert answers to graph format
        answers = [
            {"question_id": a.question_id, "answer": a.answer}
            for a in request.answers
        ]

        # Submit answers to graph
        result = submit_answers_graph(state, answers)

        # Update DB with new state
        service.update_session_state(session, result["state"])

        # Check if complete
        if result["is_complete"]:
            return InterviewCompletedResponse(
                session_id=session.id,
                is_complete=True,
                compiled_context=result["compiled_context"],
                key_insights=result["key_insights"],
                schedule=InterviewScheduleSchema(
                    daily_minutes=result["schedule"]["daily_minutes"],
                    rest_days=result["schedule"]["rest_days"],
                    intensity=result["schedule"]["intensity"],
                ),
                can_generate_roadmap=True,
            )

        # Return next questions
        questions = [
            InterviewQuestionSchema(**q)
            for q in result["questions"]
        ]

        # Determine if these are follow-up questions
        is_followup = session.followup_count > 0

        return InterviewQuestionsResponse(
            session_id=session.id,
            current_stage=result.get("current_round", 1),
            stage_name=f"라운드 {result.get('current_round', 1)}",
            questions=questions,
            is_complete=False,
            is_followup=result.get("is_followup", is_followup),
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"답변 처리 중 오류가 발생했습니다: {str(e)}",
        )


@router.get(
    "/{session_id}",
    response_model=InterviewSessionResponse,
    summary="Get interview session details",
)
async def get_session(
    session_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Get details of an interview session."""
    service = InterviewService(db)

    session = service.get_session(session_id, current_user.id)
    if not session:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="인터뷰 세션을 찾을 수 없습니다.",
        )

    stages = service.get_session_stages_info(session)

    return InterviewSessionResponse(
        id=session.id,
        user_id=session.user_id,
        topic=session.topic,
        mode=session.mode,
        duration_months=session.duration_months,
        current_stage=session.current_stage,
        status=session.status,
        stages=stages,
        is_complete=session.is_complete,
        created_at=session.created_at,
        updated_at=session.updated_at,
        roadmap_id=session.roadmap_id,
    )


@router.get(
    "/{session_id}/questions",
    response_model=InterviewQuestionsResponse,
    summary="Get current questions for a session",
)
async def get_current_questions(
    session_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Get the current questions for an in-progress session.

    Useful for resuming an interview after page refresh.
    """
    service = InterviewService(db)

    session = service.get_session(session_id, current_user.id)
    if not session:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="인터뷰 세션을 찾을 수 없습니다.",
        )

    # If interview is complete, return empty questions with is_complete=True
    if session.status == InterviewStatus.COMPLETED or session.is_complete:
        return InterviewQuestionsResponse(
            session_id=session.id,
            current_stage=session.current_stage,
            stage_name=get_stage_name(session.current_stage),
            questions=[],
            is_complete=True,
            is_followup=False,
        )

    if session.status != InterviewStatus.IN_PROGRESS:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="진행 중인 인터뷰가 아닙니다.",
        )

    questions = [
        InterviewQuestionSchema(**q)
        for q in (session.current_questions or [])
    ]

    return InterviewQuestionsResponse(
        session_id=session.id,
        current_stage=session.current_stage,
        stage_name=get_stage_name(session.current_stage),
        questions=questions,
        is_complete=False,
        is_followup=session.followup_count > 0,
    )


@router.get(
    "",
    response_model=InterviewSessionListResponse,
    summary="List interview sessions",
)
async def list_sessions(
    skip: int = 0,
    limit: int = 20,
    status_filter: Optional[InterviewStatus] = None,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """List all interview sessions for the current user."""
    service = InterviewService(db)

    sessions = service.get_sessions_for_user(
        current_user.id,
        skip=skip,
        limit=limit,
        status=status_filter,
    )
    total = service.count_sessions_for_user(current_user.id, status=status_filter)

    session_responses = []
    for session in sessions:
        stages = service.get_session_stages_info(session)
        session_responses.append(InterviewSessionResponse(
            id=session.id,
            user_id=session.user_id,
            topic=session.topic,
            mode=session.mode,
            duration_months=session.duration_months,
            current_stage=session.current_stage,
            status=session.status,
            stages=stages,
            is_complete=session.is_complete,
            created_at=session.created_at,
            updated_at=session.updated_at,
            roadmap_id=session.roadmap_id,
        ))

    return InterviewSessionListResponse(
        sessions=session_responses,
        total=total,
    )


@router.post(
    "/{session_id}/abandon",
    response_model=InterviewSessionResponse,
    summary="Abandon an interview session",
)
async def abandon_session(
    session_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Mark an interview session as abandoned."""
    service = InterviewService(db)

    session = service.abandon_session(session_id, current_user.id)
    if not session:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="인터뷰 세션을 찾을 수 없습니다.",
        )

    stages = service.get_session_stages_info(session)

    return InterviewSessionResponse(
        id=session.id,
        user_id=session.user_id,
        topic=session.topic,
        mode=session.mode,
        duration_months=session.duration_months,
        current_stage=session.current_stage,
        status=session.status,
        stages=stages,
        is_complete=session.is_complete,
        created_at=session.created_at,
        updated_at=session.updated_at,
        roadmap_id=session.roadmap_id,
    )


@router.delete(
    "/{session_id}",
    status_code=status.HTTP_204_NO_CONTENT,
    summary="Delete an interview session",
)
async def delete_session(
    session_id: UUID,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """Delete an interview session."""
    service = InterviewService(db)

    if not service.delete_session(session_id, current_user.id):
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="인터뷰 세션을 찾을 수 없습니다.",
        )
